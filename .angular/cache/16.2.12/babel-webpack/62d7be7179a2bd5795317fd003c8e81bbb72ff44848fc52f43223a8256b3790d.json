{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/jucie/Downloads/ioniclivrodoharrypotter/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n//import { Capacitor } from '@capacitor/core';\n/**\n * SQLiteConnection Class\n */\nexport class SQLiteConnection {\n  constructor(sqlite) {\n    this.sqlite = sqlite;\n    this._connectionDict = new Map();\n  }\n  initWebStore() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this.sqlite.initWebStore();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  saveToStore(database) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this2.sqlite.saveToStore({\n          database\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  saveToLocalDisk(database) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this3.sqlite.saveToLocalDisk({\n          database\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getFromLocalDiskToStore(overwrite) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const mOverwrite = overwrite != null ? overwrite : true;\n      try {\n        yield _this4.sqlite.getFromLocalDiskToStore({\n          overwrite: mOverwrite\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  echo(value) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this5.sqlite.echo({\n          value\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isSecretStored() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this6.sqlite.isSecretStored();\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  setEncryptionSecret(passphrase) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this7.sqlite.setEncryptionSecret({\n          passphrase: passphrase\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  changeEncryptionSecret(passphrase, oldpassphrase) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this8.sqlite.changeEncryptionSecret({\n          passphrase: passphrase,\n          oldpassphrase: oldpassphrase\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  clearEncryptionSecret() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this9.sqlite.clearEncryptionSecret();\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  checkEncryptionSecret(passphrase) {\n    var _this0 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this0.sqlite.checkEncryptionSecret({\n          passphrase: passphrase\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  addUpgradeStatement(database, toVersion, statements) {\n    var _this1 = this;\n    return _asyncToGenerator(function* () {\n      const upgrade = {\n        toVersion,\n        statements\n      };\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this1.sqlite.addUpgradeStatement({\n          database,\n          upgrade: [upgrade]\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  createConnection(database, encrypted, mode, version, readonly) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this10.sqlite.createConnection({\n          database,\n          encrypted,\n          mode,\n          version,\n          readonly\n        });\n        const conn = new SQLiteDBConnection(database, readonly, _this10.sqlite);\n        const connName = readonly ? `RO_${database}` : `RW_${database}`;\n        _this10._connectionDict.set(connName, conn);\n        /*\n        console.log(`*** in createConnection connectionDict: ***`)\n        this._connectionDict.forEach((connection, key) => {\n          console.log(`Key: ${key}, Value: ${connection}`);\n        });\n        */\n        return Promise.resolve(conn);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  closeConnection(database, readonly) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (database.endsWith('.db')) database = database.slice(0, -3);\n        yield _this11.sqlite.closeConnection({\n          database,\n          readonly\n        });\n        const connName = readonly ? `RO_${database}` : `RW_${database}`;\n        _this11._connectionDict.delete(connName);\n        /*      console.log(`*** in closeConnection connectionDict: ***`)\n        this._connectionDict.forEach((connection, key) => {\n          console.log(`Key: ${key}, Value: ${connection}`);\n        });\n        */\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isConnection(database, readonly) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const res = {};\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      res.result = _this12._connectionDict.has(connName);\n      return Promise.resolve(res);\n    })();\n  }\n  retrieveConnection(database, readonly) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      const connName = readonly ? `RO_${database}` : `RW_${database}`;\n      if (_this13._connectionDict.has(connName)) {\n        const conn = _this13._connectionDict.get(connName);\n        if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n          return Promise.reject(`Connection ${database} is undefined`);\n        }\n      } else {\n        return Promise.reject(`Connection ${database} does not exist`);\n      }\n    })();\n  }\n  getNCDatabasePath(path, database) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const databasePath = yield _this14.sqlite.getNCDatabasePath({\n          path,\n          database\n        });\n        return Promise.resolve(databasePath);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  createNCConnection(databasePath, version) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this15.sqlite.createNCConnection({\n          databasePath,\n          version\n        });\n        const conn = new SQLiteDBConnection(databasePath, true, _this15.sqlite);\n        const connName = `RO_${databasePath})`;\n        _this15._connectionDict.set(connName, conn);\n        return Promise.resolve(conn);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  closeNCConnection(databasePath) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this16.sqlite.closeNCConnection({\n          databasePath\n        });\n        const connName = `RO_${databasePath})`;\n        _this16._connectionDict.delete(connName);\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isNCConnection(databasePath) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const res = {};\n      const connName = `RO_${databasePath})`;\n      res.result = _this17._connectionDict.has(connName);\n      return Promise.resolve(res);\n    })();\n  }\n  retrieveNCConnection(databasePath) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (_this18._connectionDict.has(databasePath)) {\n        const connName = `RO_${databasePath})`;\n        const conn = _this18._connectionDict.get(connName);\n        if (typeof conn != 'undefined') return Promise.resolve(conn);else {\n          return Promise.reject(`Connection ${databasePath} is undefined`);\n        }\n      } else {\n        return Promise.reject(`Connection ${databasePath} does not exist`);\n      }\n    })();\n  }\n  isNCDatabase(databasePath) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this19.sqlite.isNCDatabase({\n          databasePath\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  retrieveAllConnections() {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      return _this20._connectionDict;\n    })();\n  }\n  closeAllConnections() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const delDict = new Map();\n      try {\n        /*      console.log(`*** in closeAllConnections connectionDict: ***`)\n        this._connectionDict.forEach((connection, key) => {\n          console.log(`Key: ${key}, Value: ${connection}`);\n        });\n        */\n        for (const key of _this21._connectionDict.keys()) {\n          const database = key.substring(3);\n          const readonly = key.substring(0, 3) === 'RO_' ? true : false;\n          yield _this21.sqlite.closeConnection({\n            database,\n            readonly\n          });\n          delDict.set(key, null);\n        }\n        for (const key of delDict.keys()) {\n          _this21._connectionDict.delete(key);\n        }\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  checkConnectionsConsistency() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const keys = [..._this22._connectionDict.keys()];\n        const openModes = [];\n        const dbNames = [];\n        for (const key of keys) {\n          openModes.push(key.substring(0, 2));\n          dbNames.push(key.substring(3));\n        }\n        const res = yield _this22.sqlite.checkConnectionsConsistency({\n          dbNames: dbNames,\n          openModes: openModes\n        });\n        if (!res.result) _this22._connectionDict = new Map();\n        return Promise.resolve(res);\n      } catch (err) {\n        _this22._connectionDict = new Map();\n        return Promise.reject(err);\n      }\n    })();\n  }\n  importFromJson(jsonstring) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this23.sqlite.importFromJson({\n          jsonstring: jsonstring\n        });\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isJsonValid(jsonstring) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const ret = yield _this24.sqlite.isJsonValid({\n          jsonstring: jsonstring\n        });\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  copyFromAssets(overwrite) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const mOverwrite = overwrite != null ? overwrite : true;\n      try {\n        yield _this25.sqlite.copyFromAssets({\n          overwrite: mOverwrite\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getFromHTTPRequest(url, overwrite) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const mOverwrite = overwrite != null ? overwrite : true;\n      try {\n        yield _this26.sqlite.getFromHTTPRequest({\n          url,\n          overwrite: mOverwrite\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isDatabaseEncrypted(database) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      try {\n        const res = yield _this27.sqlite.isDatabaseEncrypted({\n          database: database\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isInConfigEncryption() {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this28.sqlite.isInConfigEncryption();\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isInConfigBiometricAuth() {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this29.sqlite.isInConfigBiometricAuth();\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isDatabase(database) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      if (database.endsWith('.db')) database = database.slice(0, -3);\n      try {\n        const res = yield _this30.sqlite.isDatabase({\n          database: database\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getDatabaseList() {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this31.sqlite.getDatabaseList();\n        const values = res.values;\n        values.sort();\n        const ret = {\n          values: values\n        };\n        return Promise.resolve(ret);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getMigratableDbList(folderPath) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      try {\n        const res = yield _this32.sqlite.getMigratableDbList({\n          folderPath: path\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  addSQLiteSuffix(folderPath, dbNameList) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      const dbList = dbNameList ? dbNameList : [];\n      try {\n        const res = yield _this33.sqlite.addSQLiteSuffix({\n          folderPath: path,\n          dbNameList: dbList\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  deleteOldDatabases(folderPath, dbNameList) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      const dbList = dbNameList ? dbNameList : [];\n      try {\n        const res = yield _this34.sqlite.deleteOldDatabases({\n          folderPath: path,\n          dbNameList: dbList\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  moveDatabasesAndAddSuffix(folderPath, dbNameList) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const path = folderPath ? folderPath : 'default';\n      const dbList = dbNameList ? dbNameList : [];\n      return _this35.sqlite.moveDatabasesAndAddSuffix({\n        folderPath: path,\n        dbNameList: dbList\n      });\n    })();\n  }\n}\n/**\n * SQLiteDBConnection Class\n */\nexport class SQLiteDBConnection {\n  constructor(dbName, readonly, sqlite) {\n    this.dbName = dbName;\n    this.readonly = readonly;\n    this.sqlite = sqlite;\n  }\n  getConnectionDBName() {\n    return this.dbName;\n  }\n  getConnectionReadOnly() {\n    return this.readonly;\n  }\n  open() {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this36.sqlite.open({\n          database: _this36.dbName,\n          readonly: _this36.readonly\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  close() {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this37.sqlite.close({\n          database: _this37.dbName,\n          readonly: _this37.readonly\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  beginTransaction() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const changes = yield _this38.sqlite.beginTransaction({\n          database: _this38.dbName\n        });\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  commitTransaction() {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const changes = yield _this39.sqlite.commitTransaction({\n          database: _this39.dbName\n        });\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  rollbackTransaction() {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const changes = yield _this40.sqlite.rollbackTransaction({\n          database: _this40.dbName\n        });\n        return Promise.resolve(changes);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isTransactionActive() {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const result = yield _this41.sqlite.isTransactionActive({\n          database: _this41.dbName\n        });\n        return Promise.resolve(result);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  loadExtension(path) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this42.sqlite.loadExtension({\n          database: _this42.dbName,\n          path: path,\n          readonly: _this42.readonly\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  enableLoadExtension(toggle) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        yield _this43.sqlite.enableLoadExtension({\n          database: _this43.dbName,\n          toggle: toggle,\n          readonly: _this43.readonly\n        });\n        return Promise.resolve();\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getUrl() {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this44.sqlite.getUrl({\n          database: _this44.dbName,\n          readonly: _this44.readonly\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getVersion() {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const version = yield _this45.sqlite.getVersion({\n          database: _this45.dbName,\n          readonly: _this45.readonly\n        });\n        return Promise.resolve(version);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getTableList() {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this46.sqlite.getTableList({\n          database: _this46.dbName,\n          readonly: _this46.readonly\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  execute(_x) {\n    var _this47 = this;\n    return _asyncToGenerator(function* (statements, transaction = true, isSQL92 = true) {\n      try {\n        if (!_this47.readonly) {\n          const res = yield _this47.sqlite.execute({\n            database: _this47.dbName,\n            statements: statements,\n            transaction: transaction,\n            readonly: false,\n            isSQL92: isSQL92\n          });\n          return Promise.resolve(res);\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }).apply(this, arguments);\n  }\n  query(_x2, _x3) {\n    var _this48 = this;\n    return _asyncToGenerator(function* (statement, values, isSQL92 = true) {\n      let res;\n      try {\n        if (values && values.length > 0) {\n          res = yield _this48.sqlite.query({\n            database: _this48.dbName,\n            statement: statement,\n            values: values,\n            readonly: _this48.readonly,\n            isSQL92: true\n          });\n        } else {\n          res = yield _this48.sqlite.query({\n            database: _this48.dbName,\n            statement: statement,\n            values: [],\n            readonly: _this48.readonly,\n            isSQL92: isSQL92\n          });\n        }\n        // reorder rows for ios\n        res = yield _this48.reorderRows(res);\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }).apply(this, arguments);\n  }\n  run(_x4, _x5) {\n    var _this49 = this;\n    return _asyncToGenerator(function* (statement, values, transaction = true, returnMode = 'no', isSQL92 = true) {\n      let res;\n      try {\n        if (!_this49.readonly) {\n          if (values && values.length > 0) {\n            res = yield _this49.sqlite.run({\n              database: _this49.dbName,\n              statement: statement,\n              values: values,\n              transaction: transaction,\n              readonly: false,\n              returnMode: returnMode,\n              isSQL92: true\n            });\n          } else {\n            res = yield _this49.sqlite.run({\n              database: _this49.dbName,\n              statement: statement,\n              values: [],\n              transaction: transaction,\n              readonly: false,\n              returnMode: returnMode,\n              isSQL92: isSQL92\n            });\n          }\n          // reorder rows for ios\n          res.changes = yield _this49.reorderRows(res.changes);\n          return Promise.resolve(res);\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }).apply(this, arguments);\n  }\n  executeSet(_x6) {\n    var _this50 = this;\n    return _asyncToGenerator(function* (set, transaction = true, returnMode = 'no', isSQL92 = true) {\n      let res;\n      try {\n        if (!_this50.readonly) {\n          res = yield _this50.sqlite.executeSet({\n            database: _this50.dbName,\n            set: set,\n            transaction: transaction,\n            readonly: false,\n            returnMode: returnMode,\n            isSQL92: isSQL92\n          });\n          //      }\n          // reorder rows for ios\n          res.changes = yield _this50.reorderRows(res.changes);\n          return Promise.resolve(res);\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }).apply(this, arguments);\n  }\n  isExists() {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this51.sqlite.isDBExists({\n          database: _this51.dbName,\n          readonly: _this51.readonly\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isTable(table) {\n    var _this52 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this52.sqlite.isTableExists({\n          database: _this52.dbName,\n          table: table,\n          readonly: _this52.readonly\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  isDBOpen() {\n    var _this53 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this53.sqlite.isDBOpen({\n          database: _this53.dbName,\n          readonly: _this53.readonly\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  delete() {\n    var _this54 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this54.readonly) {\n          yield _this54.sqlite.deleteDatabase({\n            database: _this54.dbName,\n            readonly: false\n          });\n          return Promise.resolve();\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  createSyncTable() {\n    var _this55 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this55.readonly) {\n          const res = yield _this55.sqlite.createSyncTable({\n            database: _this55.dbName,\n            readonly: false\n          });\n          return Promise.resolve(res);\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  setSyncDate(syncdate) {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this56.readonly) {\n          yield _this56.sqlite.setSyncDate({\n            database: _this56.dbName,\n            syncdate: syncdate,\n            readonly: false\n          });\n          return Promise.resolve();\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  getSyncDate() {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        const res = yield _this57.sqlite.getSyncDate({\n          database: _this57.dbName,\n          readonly: _this57.readonly\n        });\n        let retDate = '';\n        if (res.syncDate > 0) retDate = new Date(res.syncDate * 1000).toISOString();\n        return Promise.resolve(retDate);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  exportToJson(_x7) {\n    var _this58 = this;\n    return _asyncToGenerator(function* (mode, encrypted = false) {\n      try {\n        const res = yield _this58.sqlite.exportToJson({\n          database: _this58.dbName,\n          jsonexportmode: mode,\n          readonly: _this58.readonly,\n          encrypted: encrypted\n        });\n        return Promise.resolve(res);\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }).apply(this, arguments);\n  }\n  deleteExportedRows() {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      try {\n        if (!_this59.readonly) {\n          yield _this59.sqlite.deleteExportedRows({\n            database: _this59.dbName,\n            readonly: false\n          });\n          return Promise.resolve();\n        } else {\n          return Promise.reject('not allowed in read-only mode');\n        }\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    })();\n  }\n  executeTransaction(_x8) {\n    var _this60 = this;\n    return _asyncToGenerator(function* (txn, isSQL92 = true) {\n      let changes = 0;\n      let isActive = false;\n      if (!_this60.readonly) {\n        try {\n          yield _this60.sqlite.beginTransaction({\n            database: _this60.dbName\n          });\n          isActive = yield _this60.sqlite.isTransactionActive({\n            database: _this60.dbName\n          });\n          if (!isActive) {\n            return Promise.reject('After Begin Transaction, no transaction active');\n          }\n        } catch (err) {\n          return Promise.reject(err);\n        }\n        try {\n          for (const task of txn) {\n            if (task.values && task.values.length > 0) {\n              const retMode = task.statement.toUpperCase().includes('RETURNING') ? 'all' : 'no';\n              const ret = yield _this60.sqlite.run({\n                database: _this60.dbName,\n                statement: task.statement,\n                values: task.values,\n                transaction: false,\n                readonly: false,\n                returnMode: retMode,\n                isSQL92: isSQL92\n              });\n              if (ret.changes.changes <= 0) {\n                throw new Error('Error in transaction method run ');\n              }\n              changes += ret.changes.changes;\n            } else {\n              const ret = yield _this60.sqlite.execute({\n                database: _this60.dbName,\n                statements: task.statement,\n                transaction: false,\n                readonly: false\n              });\n              isActive = yield _this60.sqlite.isTransactionActive({\n                database: _this60.dbName\n              });\n              if (ret.changes.changes < 0) {\n                throw new Error('Error in transaction method execute ');\n              }\n              changes += ret.changes.changes;\n            }\n          }\n          isActive = yield _this60.sqlite.isTransactionActive({\n            database: _this60.dbName\n          });\n          if (isActive) {\n            const retC = yield _this60.sqlite.commitTransaction({\n              database: _this60.dbName\n            });\n            changes += retC.changes.changes;\n          }\n          const retChanges = {\n            changes: {\n              changes: changes\n            }\n          };\n          return Promise.resolve(retChanges);\n        } catch (err) {\n          const msg = err.message ? err.message : err;\n          isActive = yield _this60.sqlite.isTransactionActive({\n            database: _this60.dbName\n          });\n          if (isActive) {\n            yield _this60.sqlite.rollbackTransaction({\n              database: _this60.dbName\n            });\n          }\n          return Promise.reject(msg);\n        }\n      } else {\n        return Promise.reject('not allowed in read-only mode');\n      }\n    }).apply(this, arguments);\n  }\n  reorderRows(res) {\n    return _asyncToGenerator(function* () {\n      const retRes = res;\n      if (res?.values && typeof res.values[0] === 'object') {\n        if (Object.keys(res.values[0]).includes('ios_columns')) {\n          const columnList = res.values[0]['ios_columns'];\n          const iosRes = [];\n          for (let i = 1; i < res.values.length; i++) {\n            const rowJson = res.values[i];\n            const resRowJson = {};\n            for (const item of columnList) {\n              resRowJson[item] = rowJson[item];\n            }\n            iosRes.push(resRowJson);\n          }\n          retRes['values'] = iosRes;\n        }\n      }\n      return Promise.resolve(retRes);\n    })();\n  }\n}\n//# sourceMappingURL=definitions.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}